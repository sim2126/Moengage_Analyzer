# -*- coding: utf-8 -*-
"""Untitled6.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uT9Y2Go8Xki2s0eErgFsJQQCZAoT6FzJ
"""

#!/usr/bin/env python3
"""
AI-Powered Documentation Improvement Agent
==========================================

A comprehensive solution for analyzing documentation and providing actionable improvement suggestions.
Designed to work with any documentation URL and provide detailed analysis with visual reports.

Features:
- Documentation content extraction and analysis
- Readability assessment for non-technical users
- Structure and flow analysis
- Completeness evaluation
- Style guidelines adherence checking
- Automated content revision suggestions
- Visual reports with tables and charts
- Interactive chatbot interface

Author: AI Documentation Agent
Compatible with: Google Colab, Jupyter Notebook, Local Python Environment
"""

import os
import re
import json
import requests
from bs4 import BeautifulSoup
from urllib.parse import urljoin, urlparse
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from textstat import flesch_kincaid_grade, gunning_fog, flesch_reading_ease
from collections import Counter
import warnings
warnings.filterwarnings('ignore')

# Optional OpenAI integration
try:
    import openai
    OPENAI_AVAILABLE = True
except ImportError:
    OPENAI_AVAILABLE = False
    print("OpenAI not available. Using built-in analysis methods.")

class DocumentationAnalyzer:
    """
    Main analyzer class that handles documentation content extraction,
    analysis, and improvement suggestions.
    """

    def __init__(self, openai_api_key=None):
        """
        Initialize the analyzer with optional OpenAI API key.

        Args:
            openai_api_key (str, optional): OpenAI API key for enhanced analysis
        """
        self.openai_client = None
        if openai_api_key and OPENAI_AVAILABLE:
            try:
                openai.api_key = openai_api_key
                self.openai_client = openai
                print("‚úÖ OpenAI API initialized successfully")
            except Exception as e:
                print(f"‚ö†Ô∏è  OpenAI initialization failed: {e}")
                print("üìù Falling back to built-in analysis methods")

        # Style guidelines configuration
        self.style_guidelines = {
            'max_sentence_length': 20,
            'max_paragraph_length': 150,
            'min_examples_per_section': 1,
            'preferred_voice': 'active',
            'jargon_words': [
                'utilize', 'facilitate', 'implement', 'leverage', 'optimize',
                'utilize', 'expedite', 'streamline', 'enhance', 'maximize'
            ],
            'complex_words_threshold': 3  # syllables
        }

    def extract_content(self, url):
        """
        Extract and clean content from a documentation URL.

        Args:
            url (str): Documentation URL to analyze

        Returns:
            dict: Extracted content with metadata
        """
        try:
            print(f"üîç Fetching content from: {url}")

            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
            }
            response = requests.get(url, headers=headers, timeout=30)
            response.raise_for_status()

            soup = BeautifulSoup(response.content, 'html.parser')

            # Remove script and style elements
            for script in soup(["script", "style", "nav", "footer", "header"]):
                script.decompose()

            # Extract title
            title = soup.find('title')
            title = title.get_text().strip() if title else "No title found"

            # Extract main content
            content_selectors = [
                'article', 'main', '.content', '#content', '.article-body',
                '.post-content', '.entry-content', '.documentation-content'
            ]

            main_content = None
            for selector in content_selectors:
                main_content = soup.select_one(selector)
                if main_content:
                    break

            if not main_content:
                main_content = soup.find('body')

            # Extract text and structure
            paragraphs = []
            headings = []
            lists = []

            if main_content:
                # Extract paragraphs
                for p in main_content.find_all('p'):
                    text = p.get_text().strip()
                    if text and len(text) > 10:
                        paragraphs.append(text)

                # Extract headings
                for level in range(1, 7):
                    for h in main_content.find_all(f'h{level}'):
                        headings.append({
                            'level': level,
                            'text': h.get_text().strip()
                        })

                # Extract lists
                for ul in main_content.find_all(['ul', 'ol']):
                    list_items = [li.get_text().strip() for li in ul.find_all('li')]
                    if list_items:
                        lists.append(list_items)

            full_text = ' '.join(paragraphs)

            return {
                'url': url,
                'title': title,
                'full_text': full_text,
                'paragraphs': paragraphs,
                'headings': headings,
                'lists': lists,
                'word_count': len(full_text.split()),
                'char_count': len(full_text)
            }

        except Exception as e:
            raise Exception(f"Failed to extract content: {str(e)}")

    def analyze_readability(self, content):
        """
        Analyze content readability for non-technical marketers.

        Args:
            content (dict): Extracted content dictionary

        Returns:
            dict: Readability analysis results
        """
        text = content['full_text']

        if not text:
            return {
                'flesch_kincaid_grade': 0,
                'gunning_fog_index': 0,
                'flesch_reading_ease': 0,
                'assessment': 'No content to analyze',
                'suggestions': ['Add content to the document']
            }

        # Calculate readability scores
        fk_grade = flesch_kincaid_grade(text)
        gf_index = gunning_fog(text)
        fre_score = flesch_reading_ease(text)

        # Analyze sentence complexity
        sentences = re.split(r'[.!?]+', text)
        avg_sentence_length = sum(len(s.split()) for s in sentences if s.strip()) / max(len([s for s in sentences if s.strip()]), 1)

        # Generate assessment
        assessment_parts = []
        suggestions = []

        if fk_grade > 12:
            assessment_parts.append(f"Reading level is college+ (Grade {fk_grade:.1f})")
            suggestions.append("Simplify vocabulary and sentence structure for broader accessibility")
        elif fk_grade > 8:
            assessment_parts.append(f"Reading level is high school (Grade {fk_grade:.1f})")
            suggestions.append("Consider simplifying some technical terms")
        else:
            assessment_parts.append(f"Reading level is accessible (Grade {fk_grade:.1f})")

        if gf_index > 17:
            assessment_parts.append("Text complexity is very high")
            suggestions.append("Break down complex sentences and reduce jargon")
        elif gf_index > 13:
            assessment_parts.append("Text complexity is moderately high")
            suggestions.append("Some sentences could be simplified")

        if fre_score < 30:
            assessment_parts.append("Text is very difficult to read")
            suggestions.append("Significantly simplify language and structure")
        elif fre_score < 60:
            assessment_parts.append("Text requires focused reading")
            suggestions.append("Add more transitional phrases and simplify where possible")

        if avg_sentence_length > 25:
            suggestions.append(f"Average sentence length ({avg_sentence_length:.1f} words) is too long - aim for 15-20 words")

        return {
            'flesch_kincaid_grade': round(fk_grade, 1),
            'gunning_fog_index': round(gf_index, 1),
            'flesch_reading_ease': round(fre_score, 1),
            'avg_sentence_length': round(avg_sentence_length, 1),
            'assessment': '. '.join(assessment_parts),
            'suggestions': suggestions
        }

    def analyze_structure(self, content):
        """
        Analyze document structure and flow.

        Args:
            content (dict): Extracted content dictionary

        Returns:
            dict: Structure analysis results
        """
        headings = content['headings']
        paragraphs = content['paragraphs']
        lists = content['lists']

        # Analyze heading hierarchy
        heading_levels = [h['level'] for h in headings]
        hierarchy_issues = []

        if not headings:
            hierarchy_issues.append("No headings found - document lacks structure")
        else:
            # Check for proper hierarchy
            for i in range(1, len(heading_levels)):
                if heading_levels[i] > heading_levels[i-1] + 1:
                    hierarchy_issues.append(f"Heading hierarchy jumps from H{heading_levels[i-1]} to H{heading_levels[i]}")

        # Analyze paragraph length
        long_paragraphs = [i for i, p in enumerate(paragraphs) if len(p.split()) > 150]
        short_paragraphs = [i for i, p in enumerate(paragraphs) if len(p.split()) < 20]

        # Calculate structure metrics
        avg_paragraph_length = sum(len(p.split()) for p in paragraphs) / max(len(paragraphs), 1)

        suggestions = []

        if len(headings) < len(paragraphs) // 5:
            suggestions.append("Add more headings to break up long sections")

        if long_paragraphs:
            suggestions.append(f"Break up {len(long_paragraphs)} overly long paragraphs")

        if not lists and len(paragraphs) > 5:
            suggestions.append("Consider using bullet points or numbered lists for better scanability")

        if hierarchy_issues:
            suggestions.extend(hierarchy_issues)

        return {
            'heading_count': len(headings),
            'paragraph_count': len(paragraphs),
            'list_count': len(lists),
            'avg_paragraph_length': round(avg_paragraph_length, 1),
            'long_paragraphs': len(long_paragraphs),
            'hierarchy_issues': hierarchy_issues,
            'suggestions': suggestions
        }

    def analyze_completeness(self, content):
        """
        Analyze content completeness and examples.

        Args:
            content (dict): Extracted content dictionary

        Returns:
            dict: Completeness analysis results
        """
        text = content['full_text'].lower()

        # Look for example indicators
        example_indicators = [
            'example', 'for instance', 'such as', 'like', 'including',
            'screenshot', 'image', 'figure', 'step 1', 'first,', 'next,'
        ]

        example_count = sum(text.count(indicator) for indicator in example_indicators)

        # Look for procedural content
        procedural_indicators = [
            'step', 'first', 'then', 'next', 'finally', 'click', 'select',
            'navigate', 'enter', 'type', 'choose'
        ]

        procedural_count = sum(text.count(indicator) for indicator in procedural_indicators)

        # Analyze content depth
        word_count = content['word_count']

        suggestions = []
        completeness_score = 0

        # Word count assessment
        if word_count < 300:
            suggestions.append("Content appears too brief - consider adding more detail")
            completeness_score += 1
        elif word_count > 2000:
            suggestions.append("Content might be too lengthy - consider breaking into sections")
            completeness_score += 2
        else:
            completeness_score += 3

        # Example assessment
        if example_count < 2:
            suggestions.append("Add more examples to illustrate concepts")
            completeness_score += 1
        else:
            completeness_score += 2

        # Procedural content assessment
        if procedural_count > 5:
            completeness_score += 2
            if example_count < procedural_count // 3:
                suggestions.append("Add visual examples or screenshots for procedural steps")

        # Check for common missing elements
        if 'prerequisite' not in text and procedural_count > 3:
            suggestions.append("Consider adding prerequisites section")

        if 'troubleshoot' not in text and 'error' not in text and procedural_count > 5:
            suggestions.append("Consider adding troubleshooting section")

        return {
            'word_count': word_count,
            'example_count': example_count,
            'procedural_count': procedural_count,
            'completeness_score': min(completeness_score, 5),
            'suggestions': suggestions
        }

    def analyze_style(self, content):
        """
        Analyze adherence to style guidelines.

        Args:
            content (dict): Extracted content dictionary

        Returns:
            dict: Style analysis results
        """
        text = content['full_text']
        paragraphs = content['paragraphs']

        issues = []
        suggestions = []

        # Voice analysis (passive vs active)
        passive_indicators = ['was', 'were', 'been', 'being', 'is', 'are']
        passive_count = sum(text.lower().count(indicator) for indicator in passive_indicators)
        total_sentences = len(re.split(r'[.!?]+', text))

        if passive_count > total_sentences * 0.3:
            issues.append("Overuse of passive voice")
            suggestions.append("Convert passive sentences to active voice where possible")

        # Jargon detection
        jargon_found = [word for word in self.style_guidelines['jargon_words']
                       if word.lower() in text.lower()]

        if jargon_found:
            issues.append(f"Business jargon detected: {', '.join(jargon_found)}")
            suggestions.append("Replace jargon with simpler, clearer terms")

        # Sentence length analysis
        sentences = [s.strip() for s in re.split(r'[.!?]+', text) if s.strip()]
        long_sentences = [s for s in sentences if len(s.split()) > self.style_guidelines['max_sentence_length']]

        if long_sentences:
            issues.append(f"{len(long_sentences)} sentences exceed recommended length")
            suggestions.append("Break long sentences into shorter, clearer statements")

        # Customer focus analysis
        customer_indicators = ['you', 'your', 'user', 'customer']
        customer_count = sum(text.lower().count(indicator) for indicator in customer_indicators)

        if customer_count < len(paragraphs):
            issues.append("Content may not be sufficiently customer-focused")
            suggestions.append("Use more second-person language (you, your) to engage readers")

        return {
            'passive_voice_ratio': round(passive_count / max(total_sentences, 1), 2),
            'jargon_words_found': jargon_found,
            'long_sentences_count': len(long_sentences),
            'customer_focus_score': min(customer_count / max(len(paragraphs), 1), 1),
            'issues': issues,
            'suggestions': suggestions
        }

    def generate_ai_insights(self, content, analysis_results):
        """
        Generate AI-powered insights and suggestions.

        Args:
            content (dict): Extracted content dictionary
            analysis_results (dict): Combined analysis results

        Returns:
            dict: AI insights and recommendations
        """
        insights = {
            'overall_score': 0,
            'priority_improvements': [],
            'content_gaps': [],
            'strength_areas': [],
            'ai_suggestions': []
        }

        # Calculate overall score
        readability_score = max(0, 5 - (analysis_results['readability']['flesch_kincaid_grade'] - 8) / 2)
        structure_score = min(5, analysis_results['structure']['heading_count'] / 3 * 5)
        completeness_score = analysis_results['completeness']['completeness_score']
        style_score = max(0, 5 - len(analysis_results['style']['issues']))

        insights['overall_score'] = round((readability_score + structure_score + completeness_score + style_score) / 4, 1)

        # Priority improvements
        all_suggestions = []
        all_suggestions.extend(analysis_results['readability']['suggestions'])
        all_suggestions.extend(analysis_results['structure']['suggestions'])
        all_suggestions.extend(analysis_results['completeness']['suggestions'])
        all_suggestions.extend(analysis_results['style']['suggestions'])

        # Prioritize suggestions
        priority_keywords = ['simplify', 'break', 'add examples', 'shorten']
        insights['priority_improvements'] = [s for s in all_suggestions
                                           if any(keyword in s.lower() for keyword in priority_keywords)][:3]

        # Identify content gaps
        text = content['full_text'].lower()
        common_sections = ['introduction', 'overview', 'getting started', 'examples', 'troubleshooting']
        insights['content_gaps'] = [section for section in common_sections if section not in text]

        # Identify strengths
        if analysis_results['readability']['flesch_kincaid_grade'] < 10:
            insights['strength_areas'].append("Good readability level")
        if analysis_results['structure']['heading_count'] > 3:
            insights['strength_areas'].append("Well-structured content")
        if analysis_results['completeness']['example_count'] > 2:
            insights['strength_areas'].append("Good use of examples")

        # AI-powered suggestions
        insights['ai_suggestions'] = [
            "Consider adding a quick start guide section",
            "Include more visual elements (diagrams, screenshots)",
            "Add a FAQ section for common questions",
            "Consider creating a checklist for key procedures"
        ]

        return insights

    def create_visual_report(self, analysis_results):
        """
        Create visual charts and tables for the analysis report.

        Args:
            analysis_results (dict): Combined analysis results
        """
        plt.style.use('seaborn-v0_8')
        fig, axes = plt.subplots(2, 2, figsize=(15, 10))
        fig.suptitle('Documentation Analysis Report', fontsize=16, fontweight='bold')

        # Readability Scores
        readability_data = {
            'Flesch-Kincaid Grade': analysis_results['readability']['flesch_kincaid_grade'],
            'Gunning Fog Index': analysis_results['readability']['gunning_fog_index'],
            'Flesch Reading Ease': analysis_results['readability']['flesch_reading_ease'] / 10  # Scale down for visualization
        }

        axes[0, 0].bar(readability_data.keys(), readability_data.values(), color=['#3498db', '#e74c3c', '#2ecc71'])
        axes[0, 0].set_title('Readability Metrics')
        axes[0, 0].set_ylabel('Score')
        axes[0, 0].tick_params(axis='x', rotation=45)

        # Structure Analysis
        structure_data = {
            'Headings': analysis_results['structure']['heading_count'],
            'Paragraphs': analysis_results['structure']['paragraph_count'],
            'Lists': analysis_results['structure']['list_count']
        }

        axes[0, 1].pie(structure_data.values(), labels=structure_data.keys(), autopct='%1.0f%%',
                      colors=['#9b59b6', '#f39c12', '#1abc9c'])
        axes[0, 1].set_title('Content Structure Distribution')

        # Completeness Score
        completeness_score = analysis_results['completeness']['completeness_score']
        axes[1, 0].bar(['Completeness Score'], [completeness_score], color='#27ae60', width=0.5)
        axes[1, 0].set_ylim(0, 5)
        axes[1, 0].set_ylabel('Score (out of 5)')
        axes[1, 0].set_title('Content Completeness')

        # Overall Insights
        ai_insights = analysis_results['ai_insights']
        overall_score = ai_insights['overall_score']

        # Create a gauge-like visualization
        theta = (overall_score / 5) * 180
        axes[1, 1].pie([theta, 180-theta], colors=['#2ecc71', '#ecf0f1'], startangle=0, counterclock=False)
        axes[1, 1].add_patch(plt.Circle((0, 0), 0.7, color='white'))
        axes[1, 1].text(0, 0, f'{overall_score}/5', ha='center', va='center', fontsize=20, fontweight='bold')
        axes[1, 1].set_title('Overall Quality Score')

        plt.tight_layout()
        plt.show()

    def generate_revision_suggestions(self, content, analysis_results):
        """
        Generate specific revision suggestions for the content.

        Args:
            content (dict): Extracted content dictionary
            analysis_results (dict): Combined analysis results

        Returns:
            dict: Detailed revision suggestions
        """
        revisions = {
            'content_revisions': [],
            'structural_changes': [],
            'style_improvements': [],
            'additional_sections': []
        }

        # Content revisions based on readability
        if analysis_results['readability']['flesch_kincaid_grade'] > 12:
            revisions['content_revisions'].append({
                'type': 'Simplify Language',
                'priority': 'High',
                'action': 'Replace complex words with simpler alternatives',
                'example': 'Change "utilize" to "use", "facilitate" to "help"'
            })

        # Structural changes
        if analysis_results['structure']['long_paragraphs'] > 0:
            revisions['structural_changes'].append({
                'type': 'Break Long Paragraphs',
                'priority': 'Medium',
                'action': f'Split {analysis_results["structure"]["long_paragraphs"]} long paragraphs',
                'guideline': 'Aim for 3-4 sentences per paragraph'
            })

        # Style improvements
        if analysis_results['style']['passive_voice_ratio'] > 0.3:
            revisions['style_improvements'].append({
                'type': 'Active Voice',
                'priority': 'Medium',
                'action': 'Convert passive voice to active voice',
                'example': 'Change "The feature is used by" to "Users use the feature"'
            })

        # Additional sections
        if analysis_results['completeness']['example_count'] < 2:
            revisions['additional_sections'].append({
                'type': 'Examples Section',
                'priority': 'High',
                'action': 'Add practical examples and use cases',
                'benefit': 'Helps users understand implementation'
            })

        return revisions

    def analyze_document(self, url):
        """
        Complete document analysis pipeline.

        Args:
            url (str): Documentation URL to analyze

        Returns:
            dict: Complete analysis results
        """
        print("üöÄ Starting documentation analysis...\n")

        # Extract content
        content = self.extract_content(url)
        print(f"‚úÖ Content extracted: {content['word_count']} words, {len(content['paragraphs'])} paragraphs\n")

        # Perform analyses
        print("üìä Analyzing readability...")
        readability = self.analyze_readability(content)

        print("üèóÔ∏è  Analyzing structure...")
        structure = self.analyze_structure(content)

        print("üîç Analyzing completeness...")
        completeness = self.analyze_completeness(content)

        print("‚úçÔ∏è  Analyzing style...")
        style = self.analyze_style(content)

        # Combine results
        analysis_results = {
            'content_info': {
                'url': content['url'],
                'title': content['title'],
                'word_count': content['word_count'],
                'char_count': content['char_count']
            },
            'readability': readability,
            'structure': structure,
            'completeness': completeness,
            'style': style
        }

        print("ü§ñ Generating AI insights...")
        ai_insights = self.generate_ai_insights(content, analysis_results)
        analysis_results['ai_insights'] = ai_insights

        print("üìù Generating revision suggestions...")
        revisions = self.generate_revision_suggestions(content, analysis_results)
        analysis_results['revisions'] = revisions

        print("üìà Creating visual report...")
        self.create_visual_report(analysis_results)

        return analysis_results

class DocumentationChatbot:
    """
    Interactive chatbot interface for the documentation analyzer.
    """

    def __init__(self, openai_api_key=None):
        """
        Initialize the chatbot with the analyzer.

        Args:
            openai_api_key (str, optional): OpenAI API key
        """
        self.analyzer = DocumentationAnalyzer(openai_api_key)
        self.conversation_history = []

    def display_welcome(self):
        """Display welcome message and instructions."""
        print("="*60)
        print("ü§ñ AI DOCUMENTATION IMPROVEMENT AGENT")
        print("="*60)
        print("Welcome! I can help you analyze and improve documentation.")
        print("\nFeatures:")
        print("‚Ä¢ üìñ Content readability analysis")
        print("‚Ä¢ üèóÔ∏è  Structure and flow evaluation")
        print("‚Ä¢ ‚úÖ Completeness assessment")
        print("‚Ä¢ ‚úçÔ∏è  Style guidelines checking")
        print("‚Ä¢ ü§ñ AI-powered insights")
        print("‚Ä¢ üìä Visual reports and charts")
        print("‚Ä¢ üìù Revision suggestions")
        print("\nCommands:")
        print("‚Ä¢ analyze <URL> - Analyze a documentation page")
        print("‚Ä¢ help - Show this help message")
        print("‚Ä¢ exit - End the session")
        print("="*60)

    def display_summary_table(self, results):
        """
        Display analysis results in a formatted table.

        Args:
            results (dict): Analysis results
        """
        print("\nüìã ANALYSIS SUMMARY")
        print("="*50)

        # Create summary DataFrame
        summary_data = {
            'Metric': [
                'Overall Score',
                'Readability Grade',
                'Reading Ease',
                'Structure Score',
                'Completeness Score',
                'Word Count',
                'Headings Count',
                'Examples Found'
            ],
            'Value': [
                f"{results['ai_insights']['overall_score']}/5",
                f"Grade {results['readability']['flesch_kincaid_grade']}",
                f"{results['readability']['flesch_reading_ease']}/100",
                f"{min(5, results['structure']['heading_count']/3*5):.1f}/5",
                f"{results['completeness']['completeness_score']}/5",
                f"{results['content_info']['word_count']} words",
                f"{results['structure']['heading_count']} headings",
                f"{results['completeness']['example_count']} examples"
            ],
            'Status': [
                'üü¢ Good' if results['ai_insights']['overall_score'] >= 4 else 'üü° Fair' if results['ai_insights']['overall_score'] >= 3 else 'üî¥ Needs Work',
                'üü¢ Good' if results['readability']['flesch_kincaid_grade'] <= 10 else 'üü° Fair' if results['readability']['flesch_kincaid_grade'] <= 14 else 'üî¥ Complex',
                'üü¢ Easy' if results['readability']['flesch_reading_ease'] >= 60 else 'üü° Standard' if results['readability']['flesch_reading_ease'] >= 30 else 'üî¥ Difficult',
                'üü¢ Good' if results['structure']['heading_count'] >= 3 else 'üü° Fair' if results['structure']['heading_count'] >= 1 else 'üî¥ Poor',
                'üü¢ Complete' if results['completeness']['completeness_score'] >= 4 else 'üü° Adequate' if results['completeness']['completeness_score'] >= 3 else 'üî¥ Incomplete',
                'üü¢ Good' if 300 <= results['content_info']['word_count'] <= 2000 else 'üü° OK' if results['content_info']['word_count'] >= 200 else 'üî¥ Too Short',
                'üü¢ Well Structured' if results['structure']['heading_count'] >= 3 else 'üü° Basic' if results['structure']['heading_count'] >= 1 else 'üî¥ No Structure',
                'üü¢ Rich' if results['completeness']['example_count'] >= 3 else 'üü° Some' if results['completeness']['example_count'] >= 1 else 'üî¥ Missing'
            ]
        }

        df = pd.DataFrame(summary_data)
        print(df.to_string(index=False))

        print(f"\nüéØ PRIORITY IMPROVEMENTS")
        print("-" * 30)
        for i, improvement in enumerate(results['ai_insights']['priority_improvements'][:3], 1):
            print(f"{i}. {improvement}")

        print(f"\nüí™ STRENGTHS")
        print("-" * 15)
        for strength in results['ai_insights']['strength_areas']:
            print(f"‚Ä¢ {strength}")

    def display_detailed_suggestions(self, results):
        """
        Display detailed improvement suggestions.

        Args:
            results (dict): Analysis results
        """
        print("\nüìù DETAILED SUGGESTIONS")
        print("="*50)

        sections = [
            ('READABILITY', results['readability']['suggestions']),
            ('STRUCTURE', results['structure']['suggestions']),
            ('COMPLETENESS', results['completeness']['suggestions']),
            ('STYLE', results['style']['suggestions'])
        ]

        for section_name, suggestions in sections:
            if suggestions:
                print(f"\n{section_name}:")
                for i, suggestion in enumerate(suggestions, 1):
                    print(f"  {i}. {suggestion}")

    def display_revision_preview(self, results):
        """
        Display a preview of suggested revisions.

        Args:
            results (dict): Analysis results
        """
        print("\nüîß REVISION SUGGESTIONS")
        print("="*50)

        revisions = results['revisions']

        if revisions['content_revisions']:
            print("\nüìù CONTENT REVISIONS:")
            for rev in revisions['content_revisions']:
                print(f"  ‚Ä¢ {rev['type']} (Priority: {rev['priority']})")
                print(f"    Action: {rev['action']}")
                if 'example' in rev:
                    print(f"    Example: {rev['example']}")
                print()

        if revisions['structural_changes']:
            print("üèóÔ∏è  STRUCTURAL CHANGES:")
            for rev in revisions['structural_changes']:
                print(f"  ‚Ä¢ {rev['type']} (Priority: {rev['priority']})")
                print(f"    Action: {rev['action']}")
                if 'guideline' in rev:
                    print(f"    Guideline: {rev['guideline']}")
                print()

        if revisions['style_improvements']:
            print("‚úçÔ∏è  STYLE IMPROVEMENTS:")
            for rev in revisions['style_improvements']:
                print(f"  ‚Ä¢ {rev['type']} (Priority: {rev['priority']})")
                print(f"    Action: {rev['action']}")
                if 'example' in rev:
                    print(f"    Example: {rev['example']}")
                print()

        if revisions['additional_sections']:
            print("‚ûï ADDITIONAL SECTIONS:")
            for rev in revisions['additional_sections']:
                print(f"  ‚Ä¢ {rev['type']} (Priority: {rev['priority']})")
                print(f"    Action: {rev['action']}")
                if 'benefit' in rev:
                    print(f"    Benefit: {rev['benefit']}")
                print()

    def generate_revised_content(self, results):
        """
        Generate a sample of revised content based on suggestions.

        Args:
            results (dict): Analysis results

        Returns:
            str: Sample revised content
        """
        print("\nü§ñ GENERATING REVISED CONTENT SAMPLE...")
        print("="*50)

        # This is a simplified example - in a full implementation,
        # this would use the OpenAI API to generate actual revisions

        sample_revisions = f"""
# REVISED CONTENT PREVIEW

## Title: {results['content_info']['title']}

### Quick Start Guide
Based on our analysis, here's how we could improve your documentation:

#### What We Found:
- Readability: Grade {results['readability']['flesch_kincaid_grade']} (Target: 8-12)
- Structure: {results['structure']['heading_count']} headings found
- Examples: {results['completeness']['example_count']} examples identified
- Overall Score: {results['ai_insights']['overall_score']}/5

#### Suggested Improvements:

**1. Simplify Language**
- Replace complex terms with simpler alternatives
- Reduce average sentence length from {results['readability']['avg_sentence_length']} to 15-20 words
- Use active voice instead of passive voice

**2. Improve Structure**
- Add more headings to break up content
- Use bullet points for lists
- Keep paragraphs to 3-4 sentences maximum

**3. Add Examples**
- Include practical use cases
- Add screenshots or code samples
- Provide step-by-step instructions

**4. Enhance Completeness**
- Add prerequisites section
- Include troubleshooting guide
- Provide related resources

#### Next Steps:
1. Implement high-priority suggestions first
2. Test revised content with target users
3. Monitor engagement and feedback
4. Iterate based on user response

---
*This is a sample revision based on AI analysis. Actual implementation would require detailed content review and rewriting.*
        """

        return sample_revisions

    def run_analysis(self, url):
        """
        Run complete analysis and display results.

        Args:
            url (str): URL to analyze
        """
        try:
            # Validate URL
            if not url.startswith(('http://', 'https://')):
                url = 'https://' + url

            # Run analysis
            results = self.analyzer.analyze_document(url)

            # Display results
            self.display_summary_table(results)
            self.display_detailed_suggestions(results)
            self.display_revision_preview(results)

            # Generate revised content sample
            revised_content = self.generate_revised_content(results)
            print(revised_content)

            # Store in conversation history
            self.conversation_history.append({
                'url': url,
                'results': results,
                'timestamp': pd.Timestamp.now()
            })

            return results

        except Exception as e:
            print(f"‚ùå Error analyzing document: {str(e)}")
            print("Please check the URL and try again.")
            return None

    def export_results(self, results, filename=None):
        """
        Export analysis results to JSON file.

        Args:
            results (dict): Analysis results
            filename (str, optional): Output filename
        """
        if not filename:
            timestamp = pd.Timestamp.now().strftime("%Y%m%d_%H%M%S")
            filename = f"doc_analysis_{timestamp}.json"

        try:
            with open(filename, 'w', encoding='utf-8') as f:
                json.dump(results, f, indent=2, ensure_ascii=False)
            print(f"‚úÖ Results exported to {filename}")
        except Exception as e:
            print(f"‚ùå Error exporting results: {str(e)}")

    def start_chat(self):
        """
        Start the interactive chat session.
        """
        self.display_welcome()

        while True:
            try:
                user_input = input("\nü§ñ Enter command (or 'help' for assistance): ").strip()

                if user_input.lower() in ['exit', 'quit', 'bye']:
                    print("üëã Thank you for using the AI Documentation Analyzer!")
                    break

                elif user_input.lower() == 'help':
                    self.display_welcome()

                elif user_input.lower().startswith('analyze '):
                    url = user_input[8:].strip()
                    if url:
                        results = self.run_analysis(url)

                        if results:
                            # Ask if user wants to export results
                            export_choice = input("\nüíæ Export results to JSON? (y/n): ").strip().lower()
                            if export_choice in ['y', 'yes']:
                                self.export_results(results)
                    else:
                        print("‚ùå Please provide a URL to analyze.")

                elif user_input.lower() == 'history':
                    if self.conversation_history:
                        print(f"\nüìö ANALYSIS HISTORY ({len(self.conversation_history)} items)")
                        print("-" * 40)
                        for i, item in enumerate(self.conversation_history, 1):
                            print(f"{i}. {item['url']}")
                            print(f"   Score: {item['results']['ai_insights']['overall_score']}/5")
                            print(f"   Time: {item['timestamp'].strftime('%Y-%m-%d %H:%M:%S')}")
                            print()
                    else:
                        print("üìö No analysis history available.")

                elif user_input.startswith('http'):
                    # Direct URL input
                    results = self.run_analysis(user_input)

                    if results:
                        export_choice = input("\nüíæ Export results to JSON? (y/n): ").strip().lower()
                        if export_choice in ['y', 'yes']:
                            self.export_results(results)

                elif user_input:
                    print("‚ùå Unknown command. Type 'help' for available commands.")

            except KeyboardInterrupt:
                print("\n\nüëã Session interrupted. Goodbye!")
                break
            except Exception as e:
                print(f"‚ùå An error occurred: {str(e)}")
                print("Please try again or type 'help' for assistance.")

# Installation and Setup Instructions
def setup_environment():
    """
    Setup function to install required packages in Colab environment.
    """
    print("üîß Setting up environment...")

    # Install required packages
    packages = [
        'requests',
        'beautifulsoup4',
        'pandas',
        'matplotlib',
        'seaborn',
        'textstat',
        'openai'  # Optional
    ]

    try:
        import subprocess
        import sys

        for package in packages:
            try:
                __import__(package.replace('-', '_'))
                print(f"‚úÖ {package} already installed")
            except ImportError:
                print(f"üì¶ Installing {package}...")
                subprocess.check_call([sys.executable, "-m", "pip", "install", package])
                print(f"‚úÖ {package} installed successfully")

        print("\nüéâ Environment setup complete!")

    except Exception as e:
        print(f"‚ùå Error setting up environment: {str(e)}")
        print("Please install packages manually using: pip install <package_name>")

# Main execution function
def main():
    """
    Main function to run the documentation analyzer.
    """
    # Setup environment (uncomment for first run in Colab)
    # setup_environment()

    print("üöÄ Starting AI Documentation Improvement Agent...")

    # Initialize with optional OpenAI API key
    openai_api_key = input("üîë Enter OpenAI API key (optional, press Enter to skip): ").strip()

    if not openai_api_key:
        openai_api_key = None
        print("üìù Running with built-in analysis methods (no OpenAI API)")

    # Start the chatbot
    chatbot = DocumentationChatbot(openai_api_key)
    chatbot.start_chat()

# Quick start function for direct analysis
def quick_analyze(url, openai_api_key=None):
    """
    Quick analysis function for direct use.

    Args:
        url (str): URL to analyze
        openai_api_key (str, optional): OpenAI API key

    Returns:
        dict: Analysis results
    """
    analyzer = DocumentationAnalyzer(openai_api_key)
    return analyzer.analyze_document(url)

# Example usage for Colab
def example_usage():
    """
    Example usage of the documentation analyzer.
    """
    print("üìö EXAMPLE USAGE")
    print("="*40)
    print()
    print("# Option 1: Interactive Chat")
    print("main()")
    print()
    print("# Option 2: Direct Analysis")
    print("results = quick_analyze('https://example.com/docs')")
    print()
    print("# Option 3: With OpenAI API")
    print("results = quick_analyze('https://example.com/docs', 'your-api-key')")
    print()
    print("# Option 4: Custom Analysis")
    print("analyzer = DocumentationAnalyzer('your-api-key')")
    print("results = analyzer.analyze_document('https://example.com/docs')")

if __name__ == "__main__":
    # Show example usage
    example_usage()
    print("\n" + "="*60)
    print("Ready to analyze documentation!")
    print("Run main() to start the interactive chat interface.")
    print("="*60)

main()

"""# MoEngage Documentation Scraping Restrictions Analysis

## Project Overview

While developing an AI-powered document analyzer for MoEngage's public documentation, I encountered significant restrictions that prevented automated scraping of their help center content.

## MoEngage's robots.txt Analysis

### Location and Access
- **URL**: `https://help.moengage.com/robots.txt`
- **Purpose**: Controls automated access to MoEngage's help center and support documentation

### Key Restrictions Identified

#### 1. Universal Bot Restrictions (`User-agent: *`)
```
Disallow: /children
Disallow: /groups
Disallow: /organizations
Disallow: /requests
Disallow: /registration
Disallow: /plans
Disallow: /accounts
Disallow: /account
Disallow: /proxy
Disallow: /rules
Disallow: /tags
Disallow: /ticket_fields
Disallow: /reports
Disallow: /search
Disallow: /slas
Disallow: /integrations
Disallow: /users
Disallow: /suspended_tickets
Disallow: /events
Disallow: /console
Disallow: /tickets
```

#### 2. Help Center Specific Restrictions
```
Disallow: /hc/activity
Disallow: /hc/change_language/
Disallow: /hc/communities/public/topics/*?*filter=
Disallow: /hc/communities/public/questions$
Disallow: /hc/communities/public/questions?*filter=
Disallow: /hc/communities/public/questions/unanswered
Disallow: /hc/*/signin
Disallow: /hc/requests/
Disallow: /hc/*/requests/
Disallow: /hc/*/search
```

#### 3. Authentication and Access Control
```
Disallow: /access/normal
Disallow: /access/sso_bypass
Disallow: /access/unauthenticated
Disallow: /theming
Disallow: /knowledge
Disallow: /access/
Disallow: /auth/
```

#### 4. CDN and Infrastructure
```
Disallow: /cdn-cgi/
```

### Special Allowances
```
Allow: /hc/*/requests/new  # Allows access to new request forms
```

### AppleBot Specific Rules
MoEngage provides special permissions for AppleBot while maintaining most restrictions, suggesting they want Apple's indexing for certain content discovery.

## Impact on My AI Document Analyzer

### Blocked Functionality
1. **Automated Documentation Crawling**: Cannot systematically crawl MoEngage's help center
2. **Search Integration**: Unable to access search endpoints for content discovery  
3. **Community Content**: Cannot analyze user-generated questions and discussions
4. **Dynamic Content**: Restricted from accessing filtered or personalized content

### What Remains Accessible
Based on the robots.txt, the following paths are likely still accessible:
- Main help center articles (not explicitly blocked)
- Static documentation pages
- General knowledge base content
- New request forms (explicitly allowed)

## Technical Implementation Considerations

### Checking MoEngage's Restrictions
```python
import urllib.robotparser

def check_moengage_access(path):
    '''
    Check if a specific MoEngage help center path can be accessed
    '''
    rp = urllib.robotparser.RobotFileParser()
    rp.set_url("https://help.moengage.com/robots.txt")
    rp.read()
    
    full_url = f"https://help.moengage.com{path}"
    can_fetch = rp.can_fetch("*", path)
    
    print(f"Path: {path}")
    print(f"Accessible: {'‚úÖ Yes' if can_fetch else '‚ùå No'}")
    return can_fetch

# Test various paths
test_paths = [
    "/hc/en-us/articles/123456789",  # Typical article
    "/hc/en-us/search",              # Search (blocked)
    "/tickets",                      # Tickets (blocked)
    "/hc/en-us/requests/new"         # New requests (allowed)
]

for path in test_paths:
    check_moengage_access(path)
```

### Sitemap Alternative
```python
import requests
import xml.etree.ElementTree as ET

def get_moengage_sitemap():
    '''
    Access MoEngage's sitemap for allowed URLs
    '''
    sitemap_url = "https://help.moengage.com/hc/sitemap.xml"
    
    try:
        response = requests.get(sitemap_url)
        if response.status_code == 200:
            root = ET.fromstring(response.content)
            urls = []
            for url in root.findall('.//{http://www.sitemaps.org/schemas/sitemap/0.9}url'):
                loc = url.find('{http://www.sitemaps.org/schemas/sitemap/0.9}loc')
                if loc is not None:
                    urls.append(loc.text)
            return urls
        else:
            print(f"Failed to access sitemap: {response.status_code}")
    except Exception as e:
        print(f"Error accessing sitemap: {e}")
    
    return []

# Get accessible URLs from sitemap
accessible_urls = get_moengage_sitemap()
print(f"Found {len(accessible_urls)} URLs in sitemap")
```

## Alternative Approaches for MoEngage Documentation

### 1. Manual Documentation Download
Since automated scraping is restricted, consider:
- Manually downloading publicly available documentation
- Using MoEngage's official API documentation if available
- Accessing their developer resources directly

### 2. Sitemap-Based Approach
```python
def analyze_moengage_via_sitemap():
    '''
    Use sitemap to identify accessible documentation
    '''
    sitemap_urls = get_moengage_sitemap()
    
    # Filter for documentation URLs
    doc_urls = [url for url in sitemap_urls if '/hc/en-us/articles/' in url]
    
    print(f"Found {len(doc_urls)} documentation articles")
    return doc_urls
```


## Conclusion

The restrictions are well-justified and highlight the importance of ethical web scraping practices in AI development projects.
However for the sake for evaluation I have built an agent which analyzes any URLs which are public.
"""